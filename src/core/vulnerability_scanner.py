"""
Vulnerability scanning and assessment module
"""

import subprocess
import json
import re
from pathlib import Path

class VulnerabilityScanner:
    def __init__(self, config, logger):
        self.config = config
        self.logger = logger
        self.vulnerabilities = []
    
    def scan(self, target, scan_results):
        """Perform vulnerability assessment"""
        self.logger.info("Starting vulnerability assessment")
        
        results = {
            'target': target,
            'vulnerabilities': [],
            'risk_score': 0,
            'recommendations': []
        }
        
        # Network vulnerabilities
        if 'network' in scan_results:
            network_vulns = self._scan_network_vulnerabilities(target, scan_results['network'])
            results['vulnerabilities'].extend(network_vulns)
        
        # Web vulnerabilities
        if 'web' in scan_results:
            web_vulns = self._scan_web_vulnerabilities(target, scan_results['web'])
            results['vulnerabilities'].extend(web_vulns)
        
        # Service-specific vulnerabilities
        if 'services' in scan_results:
            service_vulns = self._scan_service_vulnerabilities(target, scan_results['services'])
            results['vulnerabilities'].extend(service_vulns)
        
        # Calculate risk score
        results['risk_score'] = self._calculate_risk_score(results['vulnerabilities'])
        
        # Generate recommendations
        results['recommendations'] = self._generate_recommendations(results['vulnerabilities'])
        
        return results
    
    def _scan_network_vulnerabilities(self, target, network_results):
        """Scan for network-level vulnerabilities"""
        vulnerabilities = []
        
        # Check for common network vulnerabilities
        open_ports = network_results.get('open_ports', [])
        
        for port_info in open_ports:
            port = port_info.get('port')
            service = port_info.get('service', '')
            
            # Check for dangerous services
            if port in [23, 513, 514, 515]:  # Telnet, rlogin, rsh, printer
                vulnerabilities.append({
                    'type': 'Insecure Service',
                    'severity': 'High',
                    'port': port,
                    'service': service,
                    'description': f'Insecure service {service} running on port {port}',
                    'recommendation': f'Disable {service} service and use secure alternatives'
                })
            
            # Check for default ports with potential issues
            if port == 21:  # FTP
                vulnerabilities.append({
                    'type': 'Potentially Insecure Protocol',
                    'severity': 'Medium',
                    'port': port,
                    'service': service,
                    'description': 'FTP service detected - may transmit credentials in plaintext',
                    'recommendation': 'Consider using SFTP or FTPS instead of plain FTP'
                })
        
        return vulnerabilities
    
    def _scan_web_vulnerabilities(self, target, web_results):
        """Scan for web application vulnerabilities"""
        vulnerabilities = []
        
        # Check discovered directories for sensitive files
        directories = web_results.get('directories', [])
        
        for dir_info in directories:
            url = dir_info.get('url', '')
            status_code = dir_info.get('status_code', 0)
            
            # Check for sensitive file exposure
            sensitive_patterns = [
                ('.env', 'Environment Configuration File'),
                ('.git', 'Git Repository'),
                ('web.config', 'Web Configuration File'),
                ('.htaccess', 'Apache Configuration File'),
                ('wp-config.php', 'WordPress Configuration File')
            ]
            
            for pattern, description in sensitive_patterns:
                if pattern in url.lower() and status_code == 200:
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'url': url,
                        'description': f'{description} exposed: {url}',
                        'recommendation': f'Remove or restrict access to {pattern} files'
                    })
        
        # Check for directory listing
        for dir_info in directories:
            if dir_info.get('status_code') == 200:
                # This would require content analysis to detect directory listing
                pass
        
        return vulnerabilities
    
    def _scan_service_vulnerabilities(self, target, service_results):
        """Scan for service-specific vulnerabilities"""
        vulnerabilities = []
        
        services = service_results.get('services', [])
        
        for service_info in services:
            service = service_info.get('service', '')
            port = service_info.get('port', 0)
            banner = service_info.get('banner', '')
            details = service_info.get('details', {})
            
            # FTP anonymous login
            if service.lower() == 'ftp' and details.get('anonymous_login'):
                vulnerabilities.append({
                    'type': 'Authentication Bypass',
                    'severity': 'Medium',
                    'port': port,
                    'service': service,
                    'description': 'FTP allows anonymous login',
                    'recommendation': 'Disable anonymous FTP access if not required'
                })
            
            # Outdated SSH versions
            if service.lower() == 'ssh' and banner:
                if 'OpenSSH_7.' in banner or 'OpenSSH_6.' in banner:
                    vulnerabilities.append({
                        'type': 'Outdated Software',
                        'severity': 'Low',
                        'port': port,
                        'service': service,
                        'description': f'Potentially outdated SSH version: {banner}',
                        'recommendation': 'Update SSH to the latest version'
                    })
        
        return vulnerabilities
    
    def _calculate_risk_score(self, vulnerabilities):
        """Calculate overall risk score"""
        score = 0
        severity_weights = {
            'Critical': 10,
            'High': 7,
            'Medium': 4,
            'Low': 1
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Low')
            score += severity_weights.get(severity, 1)
        
        return min(score, 100)  # Cap at 100
    
    def _generate_recommendations(self, vulnerabilities):
        """Generate security recommendations"""
        recommendations = []
        
        # Generic recommendations based on vulnerabilities found
        if any(v.get('type') == 'Insecure Service' for v in vulnerabilities):
            recommendations.append('Replace insecure services with secure alternatives')
        
        if any(v.get('type') == 'Information Disclosure' for v in vulnerabilities):
            recommendations.append('Review and restrict access to sensitive files and directories')
        
        if any(v.get('type') == 'Authentication Bypass' for v in vulnerabilities):
            recommendations.append('Implement proper authentication mechanisms')
        
        if any(v.get('type') == 'Outdated Software' for v in vulnerabilities):
            recommendations.append('Update all software to the latest versions')
        
        # Always include general recommendations
        recommendations.extend([
            'Implement a Web Application Firewall (WAF)',
            'Regular security assessments and penetration testing',
            'Keep all systems and software updated',
            'Implement proper logging and monitoring',
            'Use strong authentication and access controls'
        ])
        
        return list(set(recommendations))  # Remove duplicates
